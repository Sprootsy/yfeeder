<article>
    <h2>What the Fuck Python</h2>
    <div>
<div>
  <p>The article presents a collection of surprising and unexpected behaviors in Python, often referred to as "Wat" moments. These quirks arise from Python's design choices, implementation details, and sometimes subtle nuances in the language's semantics. The examples are categorized and explained to shed light on the underlying reasons for these behaviors.</p>

  <p>One common theme involves issues related to mutability and object identity. For instance, default arguments in Python functions are evaluated only once when the function is defined, not each time the function is called. This can lead to surprising behavior when the default argument is a mutable object like a list. Modifying the list within the function's scope will affect subsequent calls because the same list object is being reused. Similarly, chained operations like `a = b = []` create multiple references to the same list object, so modifying one variable affects the others.</p>

  <p>Another set of examples involves the behavior of operators. Python's `is` operator checks for object identity, while the `==` operator checks for equality. These are not interchangeable, especially when comparing with singleton objects like `None`. Integer interning is also demonstrated, where small integers are pre-allocated and reused, leading to different `is` behavior for small vs. larger integers. The `+=` operator, when used with tuples, might appear to modify the tuple in place, but it actually creates a new tuple and reassigns the variable due to tuples being immutable.</p>

  <p>Floating-point arithmetic also causes unexpected results due to the limitations of representing decimal numbers in binary. Operations like `0.1 + 0.2` do not yield exactly `0.3` because of these representation errors. The order of comparisons can also be surprising, as `(a > b) in (a, b)` evaluates differently than expected due to how Python handles chained comparisons and boolean operations.</p>

  <p>Further examples illustrate the behavior of the `del` keyword and how it interacts with object references and garbage collection. Deleting a variable doesn't necessarily free the memory occupied by the object if other references to it exist. The behavior of class attributes versus instance attributes can also lead to confusion, especially when dealing with mutable attributes. Modifying a class attribute through an instance can sometimes create a new instance attribute, shadowing the class attribute.</p>

  <p>The interaction between Python's scoping rules and loop variables is also highlighted. Variables defined within a loop might persist after the loop has finished, and their values can be affected by the loop's final iteration. Similarly, the behavior of `try...finally` blocks is demonstrated in conjunction with `return` statements, showing that the `finally` block is always executed, even if a `return` statement is encountered in the `try` block.</p>

  <p>Additionally, the article showcases edge cases related to string interning, where Python may or may not intern strings based on their content and the compilation environment.  Empty strings and simple strings are often interned, but longer or more complex strings might not be, leading to different `is` behavior.  The behavior of list slicing is also shown to have some surprising effects.  List slicing creates new lists, but the elements of these new lists are references to the original objects. Modifying a mutable object referenced in the sliced list will affect the original list and vice versa.</p>

  <p>Finally, the article presents cases involving Python's syntax and how it's interpreted, leading to unexpected errors or results.  For example, the placement of commas and parentheses can subtly change the meaning of an expression, leading to syntax errors or unexpected tuple creation.  The `yield` keyword's behavior in different contexts and its interactions with other language features are also explored.</p>

  <h2>Key Points:</h2>
  <ul>
    <li>Mutable default arguments in functions are evaluated only once, leading to persistent changes across function calls.</li>
    <li>Chained assignments create multiple references to the same mutable object.</li>
    <li>`is` checks for object identity, while `==` checks for equality.</li>
    <li>Integer interning affects the behavior of `is` for small integers.</li>
    <li>Floating-point arithmetic can lead to representation errors.</li>
    <li>`del` removes a name binding but doesn't necessarily free the object if other references exist.</li>
    <li>Class attributes and instance attributes interact in potentially confusing ways.</li>
    <li>Loop variables can persist after the loop and retain their final values.</li>
    <li>`finally` blocks in `try...finally` are always executed, even with `return` statements.</li>
    <li>String interning behavior varies based on the string's content and environment.</li>
    </div>
</article>
