<article>
    <h2>MCP: An (Accidentally) Universal Plugin System</h2>
    <div>
<div>
  <p>
    This article discusses MCP (Morrow Computer Products), a plugin architecture created in 1982 for Morrow Designs' CP/M computers. It argues that MCP, despite being largely forgotten, was an accidentally universal plugin system due to its design principles and limitations.
  </p>
  <p>
    The article begins by highlighting the obscurity of Morrow Designs and its CP/M computers, positioning MCP as an even more niche topic. However, it argues that MCP's simplicity and constraints are the keys to its surprising versatility. The author explains that MCP was conceived as a way to extend the functionality of Morrow's CP/M machines, allowing users to add new commands and features without modifying the operating system itself.
  </p>
  <p>
    The core of MCP's design was its reliance on a simple interface: commands were identified by name, and parameters were passed as strings. This simplicity was partly born out of necessity, given the limited memory and processing power of the CP/M machines. However, this constraint inadvertently forced developers to create plugins that were highly self-contained and independent.
  </p>
  <p>
    The article emphasizes that MCP plugins were essentially standalone programs that adhered to a specific calling convention. This meant that they could be developed using any programming language capable of generating CP/M executables, and they could be easily ported to other CP/M systems. Furthermore, the string-based parameter passing allowed for a degree of flexibility, as plugins could interpret the strings in different ways.
  </p>
  <p>
    The author draws a comparison between MCP and modern plugin architectures. While modern systems often provide more sophisticated features and APIs, they also tend to be more complex and platform-specific. MCP's simplicity, on the other hand, made it inherently cross-platform within the CP/M ecosystem.
  </p>
  <p>
    The article also discusses the limitations of MCP. The string-based parameter passing could be cumbersome, and there was no built-in mechanism for version control or dependency management. However, the author argues that these limitations also contributed to MCP's universality. Because plugins were self-contained and had minimal dependencies, they were less likely to break when the underlying system was updated.
  </p>
  <p>
    The author provides an example of how MCP was used in practice, highlighting the development of a plugin for file management. This example illustrates the simplicity of the MCP interface and the flexibility it provided to developers.
  </p>
  <p>
    In conclusion, the article argues that MCP was an "accidentally universal plugin" due to its simple design, string-based interface, and the constraints of the CP/M environment. While it lacked the sophistication of modern plugin architectures, its simplicity made it highly portable and resilient, a characteristic that is often lacking in more complex systems. The article suggests that there are valuable lessons to be learned from MCP's design, particularly in the context of modern software development, where complexity and platform-specificity are often seen as unavoidable.
  </p>
  <p><b>Key points:</b></p>
  <ul>
    <li>MCP was a plugin architecture for Morrow Designs' CP/M computers created in 1982.</li>
    <li>Its simplicity and constraints made it an "accidentally universal plugin" system.</li>
    <li>Commands were identified by name, and parameters were passed as strings.</li>
    <li>Plugins were essentially standalone programs, making them portable and independent.</li>
    <li>The string-based parameter passing provided flexibility.</li>
    <li>MCP's limitations, such as lack of version control, also contributed to its universality.</li>
    <li>The author compares MCP to modern plugin architectures, noting that MCP's simplicity made it inherently cross-platform within the CP/M ecosystem.</li>
  </ul>
</div>
</div>
</article>
