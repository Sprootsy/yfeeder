<article>
    <h2>Rating 26 years of Java changes</h2>
    <div>
<div>
<p>This blog post by Neil Madden reflects on the 26 years of Java's existence, specifically focusing on the changes introduced in each major version from Java 1.0 to Java 21. The author evaluates these changes from the perspective of their impact on security, expressiveness, and overall developer experience. He describes the early days of Java with its applet-focused environment, its initial security model, and then walks through the major releases, highlighting key features and improvements. He categorizes the changes into different areas, such as language features, libraries, JVM improvements, and security enhancements.</p>

<p>The review covers Java 1.1's addition of inner classes and JavaBeans, and then Java 1.2 (Java 2) brought Swing, Collections, and a standardized security architecture. The author notes the significance of these additions in establishing Java as a mature platform. He discusses the introduction of features like NIO in Java 1.4, Generics in Java 5, and various other language and library enhancements over the years. The discussion continues to the more recent versions, such as Java 8 (Lambdas and Streams), Java 9 (Modules), Java 11 (HTTP Client and ZGC), Java 17 (Sealed Classes), and Java 21 (Virtual Threads). For each version, the author provides his assessment of the value and impact of the changes, pointing out features that significantly improved the language or addressed previous shortcomings. He also identifies areas where Java has faced challenges, like the slow adoption of modules or the complexities introduced by certain features. The blog post offers a comprehensive overview of Java's evolution and a critical assessment of its design decisions and their consequences over more than two decades.</p>

<h2>Key Points:</h2>

<ul>
<li><b>Java 1.0 - 1.1:</b> Initial release focused on applets and basic language features. Java 1.1 added inner classes and JavaBeans.</li>
<li><b>Java 1.2 (Java 2):</b> Introduced Swing, Collections Framework, and a standardized security architecture, marking a significant step in Java's maturity.</li>
<li><b>Java 1.4:</b> Included NIO (New Input/Output) for improved I/O operations.</li>
<li><b>Java 5:</b> Added Generics, Annotations, Autoboxing/Unboxing, and Enhanced For Loop, which substantially improved code safety and expressiveness.</li>
<li><b>Java 6:</b> Focused on performance and monitoring improvements, and added a scripting API.</li>
<li><b>Java 7:</b> Brought minor language enhancements like strings in switch statements and try-with-resources.</li>
<li><b>Java 8:</b> Introduced Lambda expressions and Streams, revolutionizing functional programming in Java.</li>
<li><b>Java 9:</b> Introduced the Module System (Project Jigsaw), aiming to improve modularity and encapsulation.</li>
<li><b>Java 10:</b> Introduced Local Variable Type Inference (var keyword).</li>
<li><b>Java 11:</b> Features included a new HTTP Client and the Z Garbage Collector (ZGC).</li>
<li><b>Java 17:</b> Introduced Sealed Classes, enhancing control over class hierarchies.</li>
<li><b>Java 21:</b> Featured Virtual Threads (Project Loom) for improved concurrency.</li>
<li>The author provides commentary on the impact and value of each version's changes, offering a critical perspective on Java's evolution over 26 years.</li>
</ul>
</div>
</div>
</article>
