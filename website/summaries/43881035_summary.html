<article>
    <h2>We fell out of love with Next.js and back in love with Ruby on Rails</h2>
    <div>
 <div>
   <h3>Summary</h3>
   <p>
     The article, titled "How We Fell Out of Love With Next.js (and Back in Love With Ruby on Rails & Inertia.js)", details the author's journey and their team's experience with transitioning from Next.js to Ruby on Rails with Inertia.js for building web applications. It's the first part of a series. The author initially favored Next.js due to its modern features like server-side rendering (SSR), static site generation (SSG), and a perceived performance advantage. However, over time, they encountered challenges that diminished their enthusiasm for the framework.
   </p>
   <p>
     One of the primary issues was the increasing complexity of managing the application's state and data fetching. The author notes that as the application grew, the initial simplicity of Next.js was overshadowed by the need to implement custom solutions for data fetching, caching, and state management, leading to a more complex and difficult-to-maintain codebase. They found that the "React way" of doing things often resulted in deeply nested component trees and a proliferation of props, making it harder to reason about the application's behavior.
   </p>
   <p>
     Another pain point was the deployment complexity associated with Next.js. While Next.js offers various deployment options, the author found that configuring and maintaining the deployment infrastructure, especially for SSR applications, required significant effort and expertise.
   </p>
   <p>
     In contrast, the author found Ruby on Rails, combined with Inertia.js, offered a simpler and more productive development experience. Rails provided a well-established and opinionated framework with built-in solutions for common web development tasks, such as routing, database management, and authentication. Inertia.js allowed them to use React for the front-end while leveraging the simplicity and conventions of Rails for the back-end, effectively decoupling the front-end and back-end concerns. This approach allowed them to maintain the benefits of React's component-based architecture without the complexities of building a fully client-side rendered application.
   </p>
   <p>
     The article highlights that the transition to Rails/Inertia.js resulted in a more maintainable codebase, reduced development time, and a more enjoyable development experience. The author emphasizes that while Next.js has its strengths, it may not be the best choice for all projects, and that Rails/Inertia.js can be a viable alternative for building modern web applications with a focus on simplicity and productivity. The author sets the stage for further discussion in subsequent parts of the series, likely delving into the specific technical details and benefits of their chosen stack.
   </p>
 

   <h3>Key Points</h3>
   <ul>
     <li>The author initially favored Next.js for its modern features like SSR and SSG.</li>
     <li>Complexity in state management and data fetching became a significant issue with Next.js as the application grew.</li>
     <li>Deployment of Next.js applications, especially with SSR, was found to be complex.</li>
     <li>The author transitioned to Ruby on Rails with Inertia.js.</li>
     <li>Rails provided a simpler and more productive back-end development experience.</li>
     <li>Inertia.js allowed the use of React for the front-end while leveraging Rails for the back-end.</li>
     <li>The transition resulted in a more maintainable codebase and reduced development time.</li>
     <li>The author suggests that Rails/Inertia.js can be a viable alternative to Next.js for certain projects.</li>
   </ul>
 </div>
 </div>
</article>
